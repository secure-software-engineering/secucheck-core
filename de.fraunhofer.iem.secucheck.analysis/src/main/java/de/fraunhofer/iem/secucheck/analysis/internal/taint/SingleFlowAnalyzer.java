package de.fraunhofer.iem.secucheck.analysis.internal.taint;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.common.collect.Sets;
import com.google.common.collect.Table;

import boomerang.BackwardQuery;
import boomerang.Boomerang;
import boomerang.ForwardQuery;
import boomerang.Query;
import boomerang.callgraph.ObservableICFG;
import boomerang.jimple.Statement;
import boomerang.jimple.Val;
import boomerang.seedfactory.SeedFactory;
import de.fraunhofer.iem.secucheck.query.FlowParticipant;
import de.fraunhofer.iem.secucheck.query.Input;
import de.fraunhofer.iem.secucheck.query.InputDeclaration;
import de.fraunhofer.iem.secucheck.query.Method;
import de.fraunhofer.iem.secucheck.query.MethodSet;
import de.fraunhofer.iem.secucheck.query.Output;
import de.fraunhofer.iem.secucheck.query.OutputDeclaration;
import de.fraunhofer.iem.secucheck.query.Parameter;
import de.fraunhofer.iem.secucheck.query.PartialTaintFlow;
import de.fraunhofer.iem.secucheck.query.ReturnValue;
import de.fraunhofer.iem.secucheck.query.TaintFlow;
import de.fraunhofer.iem.secucheck.query.impl.PartialTaintFlowImpl;
import soot.Body;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.jimple.AssignStmt;
import soot.jimple.IdentityStmt;
import soot.jimple.JimpleBody;
import soot.jimple.ParameterRef;
import soot.jimple.Stmt;
import soot.jimple.internal.JNopStmt;
import wpds.impl.Weight.NoWeight;

public class SingleFlowAnalyzer {

	private final PartialTaintFlow singleFlow;
	private final ObservableICFG<Unit, SootMethod> icfg;
		
	public SingleFlowAnalyzer(PartialTaintFlow singleFlow,
			ObservableICFG<Unit, SootMethod> icfg) {
		this.singleFlow = singleFlow;
		this.icfg = icfg;
	}
	
	public Map<PartialTaintFlow, Pair<Query>> analyze() {
		
		Map<PartialTaintFlow, Pair<Query>> allReachMap =
				new HashMap<PartialTaintFlow, Pair<Query>>();
		
		for (PartialTaintFlow partialFlow : getLogicalSubFlows(singleFlow)) {
			
			SeedFactory<NoWeight> seedFactory = getSeedFactory(partialFlow);
			Boomerang boomerang = getBoomerang(seedFactory);
			Seeds seeds = computeSeeds(seedFactory);
			
			if (seeds.getSources().size() != 0 && seeds.getSinks().size() != 0) {
				
				List<Method> sanitizers = getSanitizers(partialFlow);
				
				Map<SootMethod, Body> oldMethodBodies = new HashMap<SootMethod, Body>();
				Map<PartialTaintFlow, Pair<Query>> reachMap =
						new HashMap<PartialTaintFlow, Pair<Query>>();
				
				try	{
					oldMethodBodies = setEmptySootBodies(sanitizers);
					reachMap = analyzeInternal(boomerang, partialFlow, seeds.getSources(),
							seeds.getSinks());
				} finally {
					oldMethodBodies.entrySet().forEach( entry ->
						entry.getKey().setActiveBody(entry.getValue()));
				}
				
				if (reachMap.size() == 0) {
					allReachMap.clear();
					break;
				}
				
				allReachMap.putAll(reachMap);
			}
		}
		
		return allReachMap;
	}
	
	
	private Map<PartialTaintFlow, Pair<Query>> analyzeInternal(Boomerang boomerang, 
			PartialTaintFlow partialFlow, Set<ForwardQuery> sources,
			Set<BackwardQuery> sinks) {
		
		Map<PartialTaintFlow, Pair<Query>> reachMap = 
				new HashMap<PartialTaintFlow, Pair<Query>>();
		
		if (sources.size() != 0 && sinks.size() != 0) {
			// Found more sinks than sources, running forward analysis
			if (sources.size() <= sinks.size()) {
				sources.forEach(source -> boomerang.solve(source));
				reachMap = getReachingPairs(boomerang, partialFlow, sources, sinks);
			} else {
				// Found less sinks than sources, running backward analysis
				sinks.forEach(sink -> boomerang.solve(sink));
				reachMap = getReachingPairs(boomerang, partialFlow, sinks, sources);
			}
		}				
		return reachMap;
	}

	/* Each occurance of a propogator/desanitizer would break a single
	 * TaintFlow into two logical TaintFlows, this method generates 
	 * these TaintFlows. */
	private List<PartialTaintFlow> getLogicalSubFlows(
			PartialTaintFlow partialFlow) {
		
		List<PartialTaintFlow> subFlows = new ArrayList<PartialTaintFlow>();
		
		if (partialFlow.getThrough() == null || partialFlow.getThrough().size() == 0){
			subFlows.add(partialFlow);
			return subFlows;
		}
		
		for (FlowParticipant propogator :partialFlow.getThrough()) {
			
			PartialTaintFlow newFlow1 = null, newFlow2 = null;
			
			// The following try catch block is a work around the 
			// autogenerated template code's protected constructor.
			// We will need to make the constructor of 'PartialTaintFlow'
			// public or make a factory for it.
			
			// PartialTaintFlow newFlow1 = new PartialTaintFlowImpl();
			// PartialTaintFlow newFlow2 = new PartialTaintFlowImpl();
			
			try {
				Class<?> cl = Class.forName("de.fraunhofer.iem.secucheck.query.impl.PartialTaintFlowImpl");
				Constructor<?> cons = cl.getConstructor();
				newFlow1 = (PartialTaintFlow) cons.newInstance();
				newFlow2 = (PartialTaintFlow) cons.newInstance();
			} catch (Exception ex) {
				subFlows.clear();
				return subFlows;
			}
			
			newFlow1.getFrom().addAll(partialFlow.getFrom());
			newFlow1.getNotThrough().addAll(partialFlow.getNotThrough());
			newFlow1.getTo().add(propogator);
			
			newFlow2.getFrom().add(propogator);
			newFlow2.getNotThrough().addAll(partialFlow.getNotThrough());
			newFlow2.getTo().addAll(partialFlow.getTo());
			
			subFlows.add(newFlow1);
			subFlows.add(newFlow2);
		}
		
		return subFlows;
	}
	
	private Map<PartialTaintFlow, Pair<Query>> getReachingPairs(Boomerang boomerang, 
			PartialTaintFlow partialFlow, Set<? extends Query> queries,
			Set<? extends Query> reachable) {
		Map<PartialTaintFlow, Pair<Query>> reachMap = new HashMap<PartialTaintFlow, Pair<Query>>();
		for (Query start : queries) {
			for (Query end : reachable) {
				if (isValidPath(boomerang, start, end)) {
					if (start instanceof ForwardQuery) {
						reachMap.put(partialFlow, new SameTypedPair<Query>(start, end));
					} else if (start instanceof BackwardQuery) {
						reachMap.put(partialFlow, new SameTypedPair<Query>(end, start));
					}
				}
			}
		}
		return reachMap;
	}
		
	private SeedFactory<NoWeight> getSeedFactory(PartialTaintFlow partialFlow) {
		Set<SootMethod> sourceMethods = new HashSet<SootMethod>();
		Set<SootMethod> sinkMethods = new HashSet<SootMethod>();
		
		return new SeedFactory<NoWeight>() {
			@Override
			protected Collection<? extends Query> generate(SootMethod method, Stmt u) {
				Set<Query> out = Sets.newHashSet();
				
				Collection<Value> sourceVariables = generateSourceVariables(partialFlow, method, u);
				sourceVariables.forEach(v -> 
					out.add(new ForwardQuery(new Statement(u, method), new Val(v, method))) );
				
				Collection<Value> sinkVariables = generatedSinkVariables(partialFlow, method, u);
				sinkVariables.forEach(v -> 
					out.add(new BackwardQuery(new Statement(u, method), new Val(v, method))));
				
				// Find source method
				for (FlowParticipant p : partialFlow.getFrom()) {
					for (Method flowMethod : Utility.getMethods(p)) {
						if (method.toString().equals("<" + flowMethod.getSignature() + ">")) {
							sourceMethods.add(method);
						}
					}
				}

				// Find target method
				for (FlowParticipant p : partialFlow.getTo()) {
					for (Method flowMethod : Utility.getMethods(p)) {
						if (method.toString().equals("<" + flowMethod.getSignature() + ">")) {
							sinkMethods.add(method);
						}
					}
				}
				return out;
			}
			
			@Override
			public ObservableICFG<Unit, SootMethod> icfg() { return SingleFlowAnalyzer.this.icfg; }
		};
		
		// Note currently this is broken. See Ticket #10 on github.
		// https://github.com/secure-software-engineering/secucheck/issues/10

//		if (!sourceMethods.isEmpty()) {
//			taintReporter.markMethod(sourceMethods.iterator().next(), MarkerType.SOURCE_METHOD);
//		}
//		
//		if (!sinkMethods.isEmpty()) {
//			taintReporter.markMethod(sinkMethods.iterator().next(), MarkerType.SINK_METHOD);
//		}

	}
	
	private Boomerang getBoomerang(SeedFactory<NoWeight> seedFactory) {
		return new Boomerang(new TaintAnalysisOptions()) {
			@Override
			public ObservableICFG<Unit, SootMethod> icfg() {
				return SingleFlowAnalyzer.this.icfg;
			}
			
			@Override
			public SeedFactory<NoWeight> getSeedFactory() {
				return seedFactory;
			}
		};
	}

	private List<Method> getSanitizers(PartialTaintFlow partFlow) {
		List<Method> sanitizers = new ArrayList<Method>();	
		partFlow.getNotThrough().forEach(
				sanits -> Utility.getMethods(sanits).forEach(
						sanitizer->sanitizers.add(sanitizer)));
		return sanitizers;
	}
	
	private Seeds computeSeeds(SeedFactory<NoWeight> seedFactory) {
		Set<ForwardQuery> sources = Sets.newHashSet();
		Set<BackwardQuery> sinks = Sets.newHashSet();
		Collection<Query> computeSeeds = seedFactory.computeSeeds();
		for (Query q : computeSeeds) {
			if (q instanceof BackwardQuery) {
				sinks.add((BackwardQuery) q);
			} else if (q instanceof ForwardQuery) {
				sources.add((ForwardQuery) q);
			}
		} 
		return new Seeds(sources, sinks);
	}
	
	private Map<SootMethod, Body> setEmptySootBodies(List<Method> methods){
		Map<SootMethod, Body> oldBodies = new HashMap<SootMethod, Body>();
		for (Method method : methods) {
			SootMethod sootMethod = Utility.getSootMethod(method);
			if (sootMethod != null) {
				Body body = sootMethod.getActiveBody();
				if (body != null) {
					oldBodies.put(sootMethod, body);
				}
				JimpleBody replacementBody = new JimpleBody();
				replacementBody.setMethod(sootMethod);
				replacementBody.getUnits().add(new JNopStmt());
				replacementBody.insertIdentityStmts();
				sootMethod.setActiveBody(replacementBody);
			}
		}		
		return oldBodies;
	}
	
	protected Collection<Value> generateSourceVariables(PartialTaintFlow partialFlow, 
			SootMethod method, Stmt actualStatement) {
		
		for (FlowParticipant p : partialFlow.getFrom()) {
			for (Method sourceMethod : Utility.getMethods(p)) {
				String sourceSootSignature = "<" + sourceMethod.getSignature() + ">";
				Collection<Value> out = Sets.newHashSet();

				if (method.getSignature().equals(sourceSootSignature) && 
						actualStatement instanceof IdentityStmt) {
					
					IdentityStmt identity = (IdentityStmt) actualStatement;
					Value right = identity.getRightOp();
					if (right instanceof ParameterRef) {
						ParameterRef parameterRef = (ParameterRef) right;

						OutputDeclaration outputDeclaration = sourceMethod.getOutputDeclaration();
						if (outputDeclaration != null) {
							for (Output output : outputDeclaration.getOutputs()) {
								if (output instanceof Parameter) {
									int parameterIndex = ((Parameter) output).getNumber();
									if (parameterRef.getIndex() == parameterIndex
											&& method.getParameterCount() >= parameterIndex) {
										out.add(identity.getLeftOp());
									}
								}
							}

						}
					}
					return out;

				} else if (actualStatement.containsInvokeExpr()
						&& actualStatement.toString().contains(sourceSootSignature)) {

					// taint the return value
					OutputDeclaration outputDeclaration = sourceMethod.getOutputDeclaration();
					if (outputDeclaration != null) {
						for (Output output : outputDeclaration.getOutputs()) {
							if (output instanceof ReturnValue && actualStatement instanceof AssignStmt) {
								out.add(((AssignStmt) actualStatement).getLeftOp());
							} else if (output instanceof Parameter) {
								int parameterIndex = ((Parameter) output).getNumber();
								if (actualStatement.getInvokeExpr().getArgCount() >= parameterIndex) {
									out.add(actualStatement.getInvokeExpr().getArg(parameterIndex));
								}
							}
						}
					}

					// // taint this object
					// if (this.flow.getSource().getSingleSource().getTvOut() != null
					// && actualStatement.getInvokeExpr() instanceof InstanceInvokeExpr) {
					// InstanceInvokeExpr instanceInvokeExpr = (InstanceInvokeExpr)
					// actualStatement.getInvokeExpr();
					// out.add(instanceInvokeExpr.getBase());
					// }

					return out;
				}

			}
		}
//
//		if (this.flow.getSource().getValueSource() != null) // a single value source
//		{
//			// TODO:handle this
//		} 
		return Collections.emptySet();
	}

	protected Collection<Value> generatedSinkVariables(PartialTaintFlow partialFlow, 
			SootMethod method, Stmt actualStatement) {
		for (FlowParticipant p : partialFlow.getTo()) {
			for (Method sourceMethod : Utility.getMethods(p)) {
				String sourceSootSignature = "<" + sourceMethod.getSignature() + ">";
				Collection<Value> out = Sets.newHashSet();

				if (actualStatement.containsInvokeExpr() 
						&& actualStatement.toString().contains(sourceSootSignature)) {
					// taint the return value
					InputDeclaration inputDeclaration = sourceMethod.getInputDeclaration();
					if (inputDeclaration != null) {
						for (Input input : inputDeclaration.getInputs()) {
							if (input instanceof Parameter) {
								int parameterIndex = ((Parameter) input).getNumber();
								if (actualStatement.getInvokeExpr().getArgCount() >= parameterIndex) {
									out.add(actualStatement.getInvokeExpr().getArg(parameterIndex));
								}
							}
						}
					}

					// // taint this object
					// if (this.flow.getSource().getSingleSource().getTvOut() != null
					// && actualStatement.getInvokeExpr() instanceof InstanceInvokeExpr) {
					// InstanceInvokeExpr instanceInvokeExpr = (InstanceInvokeExpr)
					// actualStatement.getInvokeExpr();
					// out.add(instanceInvokeExpr.getBase());
					// }
					return out;
				}

			}
		}
		// TODO: re-check the sink structure!!
		return Collections.emptySet();
	}	

	private boolean isValidPath(Boomerang boomerang, Query start, Query end) {
		// Quick check: Is the "end" included in the Table at all?
		Statement s = end.asNode().stmt();
		Val v = end.asNode().fact();
		Table<Statement, Val, NoWeight> results = boomerang.getResults(start);
		return results.get(s, v) == null ? false : true;
	}
	
}